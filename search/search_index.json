{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TEP 2025.1 - Grupo 1: Uma Abordagem Baseada em Agentes para Detec\u00e7\u00e3o e Mitiga\u00e7\u00e3o de Ataques DoS em Ambientes Web","text":"<p>Desenvolvido para a mat\u00e9ria de T\u00f3picos Especiais em Programa\u00e7\u00e3o: Sistemas Multiagentes, ministrada por Maur\u00edcio Serrano e Milene Serrano, este projeto simula um sistema multiagente de defesa contra ataque DoS utilizando a plataforma JADE com agentes behaviour.</p>"},{"location":"#navegue-pela-documentacao","title":"Navegue pela documenta\u00e7\u00e3o:","text":"<p>Verificar documenta\u00e7\u00e3o dos agentes Verificar como \u00e9 feito o roteamento HTTP Como executar o projeto? Demonstra\u00e7\u00e3o do projeto Estrutura das pastas </p>"},{"location":"#integrantes","title":"Integrantes","text":"Foto Nome Matr\u00edcula Github Yan S. 241025480 yanrdgs-dev Gabriel A. 241025523 CODEbugging-3000 Rodrigo A. 241025855 Rodrigoatila09 Matheus P. 241025336 matheus-06 Pedro G. 241025837 pedroiaan Paulo G. 241025971 gpaulo-vit"},{"location":"agentes/","title":"Arquitetura e funcionamento dos Agentes","text":"<p>No sistema, os agentes s\u00e3o divididos da seguinte forma:</p> <ul> <li><code>MonitorAgent</code>: Monitora requisi\u00e7\u00f5es e detecta poss\u00edveis ataques;</li> <li><code>MitigatorAgent</code>: Bloqueia IPs maliciosos;</li> <li><code>UserAgent</code>: Simula as requisi\u00e7\u00f5es de um usu\u00e1rio normal;</li> <li><code>AttackAgent</code>: Simula um ataque DoS na rede;</li> <li><code>SupervisorAgent</code>: Supervisiona os agentes <code>MonitorAgent</code> e <code>MitigatorAgent</code>, de forma que garanta que sempre estar\u00e3o funcionais.</li> <li><code>CreateAttackAgent</code>: Gerencia a cria\u00e7\u00e3o de novos agentes de ataque sempre que um AttackAgent \u00e9 derrubado.</li> </ul>"},{"location":"agentes/#monitoragent","title":"<code>MonitorAgent</code>","text":"<p>O agente monitor \u00e9 respons\u00e1vel pelo monitoramento de todas as requisi\u00e7\u00f5es enviadas em dada rota por meio de uma interface <code>MonitorGateway</code> que permite que ele possa receb\u00ea-las. </p>"},{"location":"agentes/#atributos","title":"Atributos","text":"<p>O agente monitor possui dois atributo: um node, que \u00e9 a classe <code>Node</code>, que permite que o agente monitor grave e recupere as requisi\u00e7\u00f5es passadas nos \u00faltimos 10 segundos, e uma lista <code>recentRequests</code>, que guarda as \u00faltimas 1000 requisi\u00e7\u00f5es feitas.</p>"},{"location":"agentes/#metodos","title":"M\u00e9todos","text":"<p>No m\u00e9todo <code>setup()</code>, que precisa ser sobrescrito por todas as classes que possuem <code>extends Agent</code>, ou seja, que s\u00e3o agentes JADE, \u00e9 instanciado um <code>Node</code>, e o agente monitor \u00e9 registrado no <code>RequestRouter</code>.  Os comportamentos implementados no <code>setup</code> s\u00e3o: </p> <ul> <li>Comportamento C\u00edclico <code>(CyclicBehaviour)</code> para recebimento do ping do <code>SupervisorAgent</code>.</li> <li>Comportamento Ticker <code>(TickerBehaviour)</code> a cada 5 segundos <code>(5000ms)</code>, que recupera um snapshot das requisi\u00e7\u00f5es do <code>Node</code> (<code>HashMap</code> que possui a chave como sendo o IP do usu\u00e1rio e o valor como sendo o total de requisi\u00e7\u00f5es dos \u00faltimos 10 segundos), e verifica se para cada entrada no snapshot existe alguma que, no intervalo de 10 segundos, possui mais de 10 requisi\u00e7\u00f5es enviadas. Caso possua, envia uma notifica\u00e7\u00e3o (<code>ACLMessage</code>) para todos os <code>MitigatorAgent</code> no DF (Directory Facilitator) e faz um log no console.</li> <li>Comportamento Ticker <code>(TickerBehaviour)</code> a cada 10 segundos (<code>10000ms</code>) para zerar as requisi\u00e7\u00f5es do <code>Node</code>.</li> <li>M\u00e9todo <code>private void notifyMitigator(String ip)</code> que instancia um Comportamento \u00danico (<code>OneShotBehaviour</code>) busca no DF por <code>MitigatorAgent</code>, enviando um pedido para bloqueio do IP especificado.</li> <li>M\u00e9todo <code>receiveRequest(String ip)</code>, que \u00e9 a implementa\u00e7\u00e3o do <code>MonitorGateway</code>, para recebimento das requisi\u00e7\u00f5es, e adiciona ao <code>recentRequests</code> o <code>RequestRecord</code> feito pelo IP, no instante que foi feita a requisi\u00e7\u00e3o.</li> <li>M\u00e9todo <code>getRequestCountsByIp()</code>, que tamb\u00e9m \u00e9 implementa\u00e7\u00e3o do <code>MonitorGateway</code> para obter um snapshot das requisi\u00e7\u00f5es no <code>Node</code>.</li> <li>M\u00e9todo <code>getRecentRequests()</code>, que tamb\u00e9m \u00e9 implementa\u00e7\u00e3o do <code>MonitorGateway</code> para obter a lista <code>recentRequests</code> do agente monitor.</li> </ul>"},{"location":"agentes/#mitigatoragent","title":"<code>MitigatorAgent</code>","text":"<p>O agente mitigador \u00e9 respons\u00e1vel pelo bloqueio dos IPs considerados suspeitos pelo <code>MonitorAgent</code>.</p>"},{"location":"agentes/#metodos_1","title":"M\u00e9todos","text":"<p>No m\u00e9todo <code>setup()</code>, o mitigador se registra no DF para que possa receber mensagens do agente monitor.  Os comportamentos implementados no <code>setup</code> s\u00e3o:</p> <ul> <li>Comportamento C\u00edclico <code>(CyclicBehaviour)</code> para recebimento de mensagens <code>ACLMessage</code>. Nesse comportamento, o agente verifica se o <code>ConversationId</code> da mensagem \u00e9 <code>mitigation-request</code>: se for, ele bloqueia o IP solicitado na mensagem por meio do <code>RequestRouter.blockIp(ip)</code>. Se o <code>ConversatonId</code> for <code>ping-mitigator</code>, ele ir\u00e1 receber e responder o ping do <code>SupervisorAgent</code>.</li> </ul>"},{"location":"agentes/#useragent","title":"<code>UserAgent</code>","text":"<p>O agente usu\u00e1rio serve para simular requisi\u00e7\u00f5es de usu\u00e1rios comuns na rota.</p>"},{"location":"agentes/#metodos_2","title":"M\u00e9todos","text":"<p>No m\u00e9todo <code>setup()</code>, o agente usu\u00e1rio gera um IP falso para si mesmo, por meio da fun\u00e7\u00e3o <code>private String generateUserIp()</code>.  Os comportamentos implementados no <code>setup</code> s\u00e3o:</p> <ul> <li>Comportamento Ticker <code>(TickerBehaviour)</code> a cada 3 segundos <code>(3000ms)</code>, que envia requisi\u00e7\u00f5es \u00e0 rota, tendo como reader <code>X-Real-IP</code> para que possa ser corretamente simulado os IPs randomicamente gerados.</li> <li>M\u00e9todo <code>private String generateUserIp()</code> que gera um IP aleat\u00f3rio de 4 partes: <code>\"192.168.\" + part3 (n\u00famero gerado aleatoriamente) + \".\" + part4 (Idem part3)</code>. </li> </ul>"},{"location":"agentes/#attackagent","title":"<code>AttackAgent</code>","text":"<p>O agente de ataque serve para simular requisi\u00e7\u00f5es maliciosas na rota (ataque DoS).</p>"},{"location":"agentes/#metodos_3","title":"M\u00e9todos","text":"<p>No m\u00e9todo <code>setup()</code>, o agente de ataque, assim como o <code>UserAgent</code>, gera um IP falso para si mesmo, por meio da fun\u00e7\u00e3o <code>private String generateAttackIp()</code>.  Os comportamentos implementados no <code>setup</code> s\u00e3o:</p> <ul> <li>Comportamento Ticker <code>(TickerBehaviour)</code> a cada 0.2 segundos <code>(200ms)</code>, que envia requisi\u00e7\u00f5es \u00e0 rota, tendo como header <code>X-Real-IP</code> para que possa ser corretamente simulado os IPs randomicamente gerados.</li> <li>M\u00e9todo <code>private String generateAttackIp()</code> que gera um IP aleat\u00f3rio de 4 partes: <code>\"10.0.\" + part3 (n\u00famero gerado aleatoriamente) + \".\" + part4 (Idem part3)</code>. Esse m\u00e9todo \u00e9 diferente do <code>generateUserIp</code> para que, na situa\u00e7\u00e3o de simula\u00e7\u00e3o, n\u00e3o ocorram casos onde sejam instanciados 2 agentes (<code>UserAgent</code> e <code>AttackAgent</code>) com o mesmo IP, mesmo que sejam m\u00ednimos.</li> </ul> <p>H\u00e1 tamb\u00e9m o m\u00e9todo <code>takedown()</code>, que permite que o <code>AttackAgent</code>, ao ser derrubado, envie uma mensagem ao <code>CreateAttackAgent</code>, para que sejam instanciados novos agentes no lugar dele.</p>"},{"location":"agentes/#supervisoragent","title":"<code>SupervisorAgent</code>","text":"<p>O agente supervisor serve para supervisionar os agentes <code>MonitorAgent</code> e <code>MitigatorAgent</code> por meio de pings peri\u00f3dicos.</p>"},{"location":"agentes/#atributos_1","title":"Atributos","text":"<ul> <li><code>private static final String MONITOR_NAME</code> que guarda o <code>LocalName</code> do agente monitor.</li> <li><code>private static final String MITIGATOR_NAME</code> que guarda o <code>LocalName</code> do agente mitigador.</li> <li><code>private boolean monitorAlive</code>, vari\u00e1vel booleana do estado de vida do monitor.</li> <li><code>private boolean mitigatorAlive</code>, vari\u00e1vel booleana do estado de vida do mitigador.</li> </ul>"},{"location":"agentes/#metodos_4","title":"M\u00e9todos","text":"<p>No m\u00e9todo <code>setup()</code>, o agente supervisor implementa os seguintes comportamentos:</p> <ul> <li>Comportamento Ticker <code>(TickerBehaviour)</code> a cada 7 segundos <code>(7000ms)</code>, que envia uma <code>ACLMessage</code> com o ConversationId <code>ping-monitor</code>, para verificar se o monitor est\u00e1 vivo.</li> <li>Comportamento Ticker <code>(TickerBehaviour)</code> a cada 0.5 segundos <code>(500ms)</code> para verificar se houve alguma resposta \u00e0 mensagem com conte\u00fado <code>pong-monitor</code>. Se houver, seta <code>monitorAlive = true</code>.</li> <li>Comportamento Ticker <code>(TickerBehaviour)</code> a cada 10 segundos <code>(10000ms)</code>, que envia uma <code>ACLMessage</code> com o ConversationId <code>ping-mitigador</code>, para verificar se o mitigador est\u00e1 vivo.</li> <li>Comportamento Ticker <code>(TickerBehaviour)</code> a cada 1 segundo <code>(1000ms)</code>, para verificar se houve alguma resposta \u00e0 mensagem com conte\u00fado <code>pong-mitigador</code>. Se houver, seta <code>mitigatorAlive = true</code>.</li> <li>Comportamento Ticker <code>(TickerBehaviour)</code> a cada 10 segundos <code>(10000ms)</code> em que, caso <code>monitorAlive = false</code>, ele reinicia o <code>MonitorAgent</code> da plataforma JADE.</li> <li>Comportamento Ticker <code>(TickerBehaviour)</code> a cada 10 segundos <code>(10000ms)</code> em que, caso <code>mitigatorAlive = false</code>, ele reinicia o <code>MitigatorAgent</code> da plataforma JADE.</li> </ul>"},{"location":"agentes/#createattackagent","title":"<code>CreateAttackAgent</code>","text":"<p>Para fazer a simula\u00e7\u00e3o de ataques constantes na rede de forma a testar o sistema multiagente, foi criado um Agente que envia ataques ao servidor.</p>"},{"location":"agentes/#atributos_2","title":"Atributos","text":"<p>O <code>CreateAttackAgent</code> possui apenas um atributo: um int <code>userName</code>, para contabilizar o n\u00famero dos agentes ao recri\u00e1-los e nome\u00e1-los.</p>"},{"location":"agentes/#metodos_5","title":"M\u00e9todos","text":"<p>No m\u00e9todo <code>setup()</code>, o agente implementa os seguintes comportamentos: - Comportamento C\u00edclico <code>(CyclicBehaviour)</code>, que recebe uma mensagem que o <code>AttackAgent</code> envia ao ser derrubado. Dentro desse comportamento, h\u00e1 o Comportamento Acordador <code>(WakerBehaviour)</code>, que inicia ap\u00f3s 3 segundos <code>(3000ms)</code>, que cria um novo <code>AttackAgent</code> por meio do m\u00e9todo <code>public boolean CreateAgent()</code>. - ** M\u00e9todo <code>public boolean CreateAgent()</code>, que tenta criar um novo agente de ataque, com nome <code>ATTACK_{userName}</code>, incrementando o userName a cada itera\u00e7\u00e3o.</p>"},{"location":"agentes/#classe-node","title":"Classe <code>Node</code>","text":"<p>A classe <code>Node</code> foi feita para facilitar os acessos \u00e0s requisi\u00e7\u00f5es pelo <code>MonitorAgent</code>. Ela inclui m\u00e9todos e atributos que auxiliam na busca das requisi\u00e7\u00f5es pelo agente monitor.</p>"},{"location":"agentes/#atributos_3","title":"Atributos","text":"<ul> <li><code>private final Map&lt;String, Integer&gt; requests</code>, que \u00e9 um <code>HashMap</code> que guarda o IP e o total de requisi\u00e7\u00f5es feitas pelo usu\u00e1rio.</li> </ul>"},{"location":"agentes/#metodos_6","title":"M\u00e9todos","text":"<ul> <li><code>public synchronized void registerRequest(String ip)</code>, m\u00e9todo para registrar as requisi\u00e7\u00f5es no <code>HashMap</code>.</li> <li><code>public synchronized Map&lt;String, Integer&gt; getRequestSnapshot()</code>, m\u00e9todo para obter uma snapshot do <code>HashMap</code>.</li> <li><code>public synchronized void resetRequests()</code>, para limpar as requisi\u00e7\u00f5es feitas. </li> </ul>"},{"location":"demo/","title":"Demonstra\u00e7\u00e3o do projeto","text":"<p>Temos um v\u00eddeo no reposit\u00f3rio onde demonstramos o projeto como um todo. Assista ao v\u00eddeo aqui:</p> <p>Al\u00e9m disso, temos algumas screenshots para ilustrar o funcionamento do projeto:</p> Logs dos agentes no terminal Logs dos agentes no terminal e agentes no cont\u00eainer JADE Dashboard para visualiza\u00e7\u00e3o dos dados e logs Logs selecionados do console no Dashboard"},{"location":"estrutura/","title":"Estrutura das pastas do projeto","text":"<p>Abaixo, segue a estrutura completa das pastas do projeto:</p> <pre><code> src\n  \u2514\u2500\u2500 main\n      \u251c\u2500\u2500 java\n      \u2502   \u251c\u2500\u2500 agentes\n      \u2502   \u2502   \u251c\u2500\u2500 AttackAgent.java\n      \u2502   \u2502   \u251c\u2500\u2500 CreateAttackAgent.java\n      \u2502   \u2502   \u251c\u2500\u2500 MitigatorAgent.java\n      \u2502   \u2502   \u251c\u2500\u2500 MonitorAgent.java\n      \u2502   \u2502   \u251c\u2500\u2500 SupervisorAgent.java\n      \u2502   \u2502   \u2514\u2500\u2500 UserAgent.java\n      \u2502   \u251c\u2500\u2500 core\n      \u2502   \u2502   \u251c\u2500\u2500 DataStore.java\n      \u2502   \u2502   \u251c\u2500\u2500 LogStore.java\n      \u2502   \u2502   \u251c\u2500\u2500 Node.java\n      \u2502   \u2502   \u251c\u2500\u2500 RequestRecord.java\n      \u2502   \u2502   \u2514\u2500\u2500 RequestRouter.java\n      \u2502   \u251c\u2500\u2500 infra\n      \u2502   \u2502   \u251c\u2500\u2500 MonitorGateway.java\n      \u2502   \u2502   \u2514\u2500\u2500 MonitoringAPI.java\n      \u2502   \u2514\u2500\u2500 Main.java\n      \u2514\u2500\u2500 resources\n          \u2514\u2500\u2500 public\n              \u2514\u2500\u2500 site\n                  \u251c\u2500\u2500 static\n                  \u2502   \u251c\u2500\u2500 dashboard.css\n                  \u2502   \u251c\u2500\u2500 dashboard.js\n                  \u2502   \u251c\u2500\u2500 index.css\n                  \u2502   \u2514\u2500\u2500 index.js\n                  \u251c\u2500\u2500 dashboard.html\n                  \u2514\u2500\u2500 index.html\n</code></pre>"},{"location":"execucao/","title":"Como executar o projeto","text":"<p>Para rodar o projeto, \u00e9 necess\u00e1rio apenas que voc\u00ea possua o Maven instalado. Para checar isso, digite em seu terminal:</p> <pre><code>mvn --version\n</code></pre> <p>Caso n\u00e3o esteja instalado, instale-o:</p> <pre><code># Windows\nchoco install maven # ou\nscoop install maven\n\n# Linux\nsudo apt install maven # ou\nsudo dnf install maven\n\n# macOS\nbrew install maven\n</code></pre> <p>Ap\u00f3s isso, basta rodar o script auxiliar:</p> <pre><code># Linux\nchmod +x run.sh\n./run.sh\n\n# Windows\n.\\run.bat\n\n# macOS\nchmod +x run.sh\n./run.sh # ou\nsh run.sh\n</code></pre> <p>Ent\u00e3o, o Maven cuidar\u00e1 de todo o processo de build e o sistema ser\u00e1 iniciado.</p>"},{"location":"execucao/#como-acessar-o-dashboard","title":"Como acessar o dashboard","text":"<p>Para utilizar o dashboard, basta rodar o <code>run.sh</code> ou <code>run.bat</code> e visitar o endere\u00e7o localhost:8080.</p>"},{"location":"overview/","title":"Vis\u00e3o Geral","text":"<p>Este projeto simula agentes que monitoram rotas HTTP e verificam e bloqueiam poss\u00edveis ataques DOS. Todo esse processo \u00e9 feito de forma acoplada a um servidor (Nesse caso, o Spark), permitindo maior modularidade do projeto. Al\u00e9m disso, h\u00e1 uma resist\u00eancia a falhas, pois caso um agente cr\u00edtico pare de responder, ele \u00e9 derrubado e reiniciado.</p>"},{"location":"rotas/","title":"Roteamento HTTP","text":"<p>Para o funcionamento do sistema, \u00e9 necess\u00e1rio que haja um servidor configurado. No caso, o servidor escolhido foi o Spark, que permite configurar rotas rapidamente. Por\u00e9m, os agentes podem ser acoplados a qualquer tipo de servidor que forne\u00e7a roteamento HTTP.</p>"},{"location":"rotas/#como-e-feito-o-acoplamento-entre-servidor-e-agente","title":"Como \u00e9 feito o acoplamento entre servidor e agente","text":"<p>Na classe <code>RequestRouter</code>, localizada no pacote <code>core</code>, existem alguns atributos e m\u00e9todos cruciais para a integra\u00e7\u00e3o com os agentes do sistema:</p> <ul> <li><code>MonitorGateway monitor</code>: permite que as requisi\u00e7\u00f5es possam ser enviadas ao monitor por meio de uma interface.</li> <li><code>blockedIps</code>: guarda os IPs bloqueados previamente pelo sistema.</li> <li><code>ExecutorService executor</code>: permite fixar o n\u00famero de threads, limitando a concorr\u00eancia e tornando o servidor mais est\u00e1vel.</li> <li>M\u00e9todo <code>public static void registerMonitor(MonitorGateway m)</code>: permite registrar um agente monitor <code>m</code> ao <code>MonitorGateway</code>. Esse m\u00e9todo \u00e9 chamado no <code>setup</code> do <code>MonitorAgent</code>.</li> <li>M\u00e9todo <code>public static void blockIp(String ip)</code>: adiciona o IP bloqueado ao <code>blockedIps</code>. Esse m\u00e9todo \u00e9 chamado pelo <code>MitigatorAgent</code>.</li> </ul>"},{"location":"rotas/#como-configurar-rotas-no-sistema","title":"Como configurar rotas no sistema","text":"<p>A configura\u00e7\u00e3o das rotas se torna uma tarefa muito f\u00e1cil quando usamos o Spark. Precisamos apenas configurar o tipo do m\u00e9todo HTTP (<code>GET</code>, <code>POST</code>, <code>DELETE</code>, <code>PUT</code>) e a rota que deseja criar. Dentro da rota, \u00e9 crucial que haja o seguinte bloco de c\u00f3digo:</p> <pre><code>post(\"/\", (req, res) -&gt; {\n    String ip = req.ip();\n\n    if (blockedIps.contains(ip)) {\n        res.status(403);\n        return \"Blocked\"; // Ou outro retorno, pode ser uma p\u00e1gina HTML\n    }\n\n    if (monitor != null) {\n        final String ipCopy = ip;\n        executor.submit(() -&gt; {\n            try {\n                monitor.receiveRequest(ipCopy);\n            } catch (Exception e) {\n                System.err.println(\"[ROUTER] Erro ao enviar IP ao monitor: \" + e.getMessage());\n            }\n        });\n    }\n\n    // Insira a l\u00f3gica do endpoint aqui\n});\n</code></pre> <p>Com isso, podemos acoplar o sistema a qualquer rota HTTP de um servidor.</p>"},{"location":"rotas/#fluxo-de-dados-e-armazenamento","title":"Fluxo de Dados e Armazenamento","text":"<p>O sistema utiliza duas principais estruturas para armazenamento e gerenciamento de dados:</p>"},{"location":"rotas/#1-node-pacote-core","title":"1. <code>Node</code> (pacote <code>core</code>)","text":"<p>A classe <code>Node</code> atua como um ponto de coleta e armazenamento de requisi\u00e7\u00f5es por IP. Ela mant\u00e9m um <code>ConcurrentHashMap&lt;String, List&lt;RequestRecord&gt;&gt;</code> chamado <code>ipRequests</code>, que armazena listas de requisi\u00e7\u00f5es (<code>RequestRecord</code>) associadas a cada IP. Essa estrutura permite que os agentes monitorem e analisem o comportamento de cada IP individualmente.</p>"},{"location":"rotas/#2-datastore-pacote-core","title":"2. <code>DataStore</code> (pacote <code>core</code>)","text":"<p>A classe <code>DataStore</code> serve como um reposit\u00f3rio centralizado para os dados coletados pelos agentes. Ela tamb\u00e9m utiliza um <code>ConcurrentHashMap&lt;String, List&lt;RequestRecord&gt;&gt;</code> para armazenar as requisi\u00e7\u00f5es, permitindo uma vis\u00e3o geral do tr\u00e1fego na rede. Al\u00e9m disso, o <code>DataStore</code> fornece m\u00e9todos para acessar e manipular esses dados, facilitando a an\u00e1lise e a gera\u00e7\u00e3o de relat\u00f3rios.</p>"},{"location":"rotas/#3-logstore-pacote-core","title":"3. <code>LogStore</code> (pacote <code>core</code>)","text":"<p>A classe <code>LogStore</code> \u00e9 respons\u00e1vel por armazenar os logs gerados pelos agentes. Ela utiliza uma lista sincronizada para armazenar mensagens de log, permitindo que o sistema mantenha um hist\u00f3rico das a\u00e7\u00f5es e eventos ocorridos durante a execu\u00e7\u00e3o.</p>"},{"location":"rotas/#4-requestrecord-pacote-core","title":"4. <code>RequestRecord</code> (pacote <code>core</code>)","text":"<p>A classe <code>RequestRecord</code> representa uma requisi\u00e7\u00e3o individual feita por um IP. Ela armazena informa\u00e7\u00f5es como o IP de origem e o timestamp da requisi\u00e7\u00e3o, permitindo que os agentes analisem padr\u00f5es de comportamento e detectem poss\u00edveis ataques.</p>"},{"location":"rotas/#integracao-com-a-api-de-monitoramento","title":"Integra\u00e7\u00e3o com a API de Monitoramento","text":"<p>A classe <code>MonitoringAPI</code>, localizada no pacote <code>infra</code>, fornece endpoints HTTP para acessar os dados armazenados no sistema. Ela permite que usu\u00e1rios e administradores consultem informa\u00e7\u00f5es como:</p> <ul> <li>Lista de IPs bloqueados.</li> <li>Requisi\u00e7\u00f5es feitas por cada IP.</li> <li>Logs gerados pelos agentes.</li> </ul> <p>Esses endpoints s\u00e3o \u00fateis para monitorar o estado atual da rede e tomar decis\u00f5es informadas sobre a\u00e7\u00f5es de mitiga\u00e7\u00e3o.</p>"}]}